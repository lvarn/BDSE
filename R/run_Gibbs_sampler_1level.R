#' Gibbs sampler (single-level coverage model)
#'
#' This function runs a Gibbs sampler to approximate the posterior predictive 
#' distribution of the unobserved portion of the target population, given the
#' portion of the population observed (in Lists 1 and 2).
#'
#' The function assumes that, along with the covariates, the data.frame
#' \code{obs_distribution} includes columns of counts for the four cells, named
#' \code{Y11}, \code{Y10}, \code{Y01}, and \code{Y00}.
#'
#' @inheritParams arguments
#' @inheritParams run_Gibbs_sampler_2levela
#' @param initial_vals A named list with initial values for the relavent model
#'   parameters: here, the coefficient vectors \code{coefficients1} and
#'   \code{coefficients2}.
#'
#' @return A named list of parameter values generated by the Gibbs sampler: 
#'   \itemize{ 
#'     \item \code{n_target} A vector of sampled target population sizes;
#'     \item \code{coefficients1, coefficients2}: Matrices of sampled 
#'       coefficients for the coverage models of lists 1 and 2; 
#'     \item \code{update_coef1, update_coef2}: Each a vector indicating whether
#'       the coefficients vector for the corresponding list was updated at each
#'       iteration; 
#'     \item \code{log_like1, log_like2}: Each a vector of log-likelihoods of
#'       the coefficients vector for the corresponding list.
#'     \item \code{run_time}: The run-time of the Gibbs sampler.
#'   }
#' 
#' @examples
#' n_obs  <- 100000 
#' n_sims <- 10L 
#' 
#' L     <- data.frame(L1 = c(1, 1, 0), 
#'                     L2 = c(1, 0, 1))[sample(3, n_obs, replace = TRUE), ]
#'                     
#' D_obs <- data.frame(age = sample(90, n_obs, replace = TRUE),
#'                     sex = sample(c("M", "F"), n_obs, replace = TRUE),
#'                     Y11 = as.integer(L[[1]] & L[[2]]),
#'                     Y10 = as.integer(L[[1]] & !L[[2]]),
#'                     Y01 = as.integer(!L[[1]] & L[[2]]),
#'                     Y00 = 0L)
#' 
#' obs_distribution <- BDSE::distribute(
#'                       D_obs,
#'                       contract_cols = c("Y11", "Y10", "Y01", "Y00"))
#'
#' cover_formula <- ~ age + sex  # terms: Intercept, age, and sexM (or sexF)
#' 
#' initial_vals  <- list(coefficients1 = c(0.5, 0.001, 0.75),
#'                       coefficients2 = c(0.5, 0.001, 0.75))
#'  
#' n_coef1 <- length(initial_vals[["coefficients1"]])
#' n_coef2 <- length(initial_vals[["coefficients2"]])
#' 
#' Gibbs_sample <- run_Gibbs_sampler_1level(
#'                   seed               = 296,
#'                   n_sims             = n_sims,
#'                   obs_distribution   = obs_distribution,
#'                   formula1           = cover_formula,
#'                   formula2           = cover_formula,
#'                   proposal_cov_coef1 = diag(0.5, nrow = n_coef1),
#'                   proposal_cov_coef2 = diag(0.5, nrow = n_coef2),
#'                   prior_mean_coef1   = rep(0, n_coef1),
#'                   prior_mean_coef2   = rep(0, n_coef2),
#'                   prior_cov_coef1    = diag(100^2, nrow = n_coef1),
#'                   prior_cov_coef2    = diag(100^2, nrow = n_coef2),
#'                   initial_vals       = initial_vals,
#'                 # periodic_save      = list(every = n_sims,
#'                 #                           where = file.path(getwd(), "out")),
#'                   print_every        = 1L)
#' 
#' str(Gibbs_sample)
#'
#' @export
run_Gibbs_sampler_1level <- function(
                              seed,
                              n_sims,
                              obs_distribution,
                              formula1,
                              formula2,
                              proposal_cov_coef1,
                              proposal_cov_coef2,
                              prior_mean_coef1,
                              prior_mean_coef2,
                              prior_cov_coef1,
                              prior_cov_coef2,
                              initial_vals = NULL,
                              restart_from = NULL,
                              proposal_scale_coef1 = 1,
                              proposal_scale_coef2 = 1,
                              func_n_target_posterior = 
                                list(func = BDSE:::draw_n_target_jeffreys,
                                     args = NULL),
                              periodic_save   = NULL,
                              print_every     = 0L,
                              record_count    = function(...) FALSE,
                              return_obs_dist = FALSE) {
  ## Initialise
  set.seed(seed)
  start_time      <- Sys.time()
  start_date_time <- format(start_time, "%Y%m%d_%H%M%S")  # for file name
 
  ## Design matrix and cell counts
  X_obs <- lapply(list(list1 = formula1, 
                       list2 = formula2), 
                  stats::model.matrix,
                  data = obs_distribution)
  
  cells <- obs_distribution[, c("Y11", "Y10", "Y01", "Y00")]
  
  n_obs <- sum(cells[["Y11"]]) + sum(cells[["Y10"]]) + sum(cells[["Y01"]])

  ## Storage output and initial values
  if (!is.null(restart_from)) {
    stored  <- lapply(restart_from, add_storage, n = n_sims)
    start_n <- length(restart_from[["n_target"]]) - 1
    theta   <- restart_from[["theta"]]
    p1      <- restart_from[["p1"]]
    p2      <- restart_from[["p2"]]
  } else {
      stored <- BDSE:::initialise_output_storage(
                  n            = n_sims,
                  q1           = length(initial_vals[["coefficients1"]]),
                  q2           = length(initial_vals[["coefficients2"]]),
                  initial_vals = initial_vals)
      
      colnames(stored[["coefficients1"]]) <- colnames(X_obs[[1]])
      colnames(stored[["coefficients2"]]) <- colnames(X_obs[[2]])
      
      ## Initial coverage probabilities and covariate probabilities
      p1 <- BDSE:::invlogit(
              as.vector(X_obs[[1]] %*% stored[["coefficients1"]][1, ]))
      p2 <- BDSE:::invlogit(
              as.vector(X_obs[[2]] %*% stored[["coefficients2"]][1, ]))
      
      theta   <- as.vector(gtools::rdirichlet(n = 1, 
                                              1 / (1 - (1 - p1) * (1 - p2))))
      start_n <- 0
  }
 
  ## Gibbs sampler
  for (i in start_n + 1:n_sims) {
    ## Draw missing data indices and build missing dataset
    sampled_row_ids <- 
      BDSE:::draw_missing_data_indices(
        n_observed              = n_obs,
        X_obs1                  = X_obs[[1]],
        X_obs2                  = X_obs[[2]],
        coefficients1           = stored[["coefficients1"]][i, ],
        coefficients2           = stored[["coefficients2"]][i, ],
        theta                   = theta,
        draw_n_target_posterior = func_n_target_posterior[["func"]],
        n_target_posterior_args = func_n_target_posterior[["args"]])
    
    stored[["n_target"]][i + 1] <- n_obs + length(sampled_row_ids)
    
    cells[["Y00"]] <- BDSE:::make_count(nrow(obs_distribution), 
                                        sampled_row_ids)
    counts         <- rowSums(cells)
    
    ## Update parameters for each list 
    for (list_id in 1:2) {
      y <- cells[["Y11"]] + if (list_id == 1) cells[["Y10"]] else cells[["Y01"]]
      
      ## Update and store logistic coverage model coefficients
      updated_coefficients <- 
        BDSE:::draw_coefficients(
          current_coefficients = stored[[paste0("coefficients", list_id)]][i, ],
          prior_mean           = get(paste0("prior_mean_coef", list_id)),
          prior_cov            = get(paste0("prior_cov_coef", list_id)),
          proposal_cov         = get(paste0("proposal_cov_coef", list_id)),
          proposal_scale       = get(paste0("proposal_scale_coef", list_id)),
          X                    = X_obs[[list_id]],
          y                    = y,
          counts               = counts)
      
      stored[[paste0("coefficients", list_id)]][i + 1, ] <- 
                                        updated_coefficients[["coefficients"]]
      stored[[paste0("log_like", list_id)]][i + 1] <- 
                                        updated_coefficients[["log_likelihood"]]
      stored[[paste0("update_coef", list_id)]][i + 1]    <- 
                                        updated_coefficients[["was_updated"]]
    }

    ## Update theta (target covariate distribution)
    theta <- as.vector(gtools::rdirichlet(1, counts))
    
    ## Save subpopulation counts
    if (record_count(i)) {
      if (is.null(stored[["out_counts"]])) 
        stored[["out_counts"]] <- obs_distribution[, return_obs_dist]
      stored[["out_counts"]][[paste0("counts_", i)]] <- counts
    }
    
    ## Periodically save results to .RDS file (overwrites previous save)
    if (!is.null(periodic_save)) {
      if (!i %% periodic_save[["every"]]) {
        file_name <- make_file_path(path = periodic_save[["where"]],
                                    model = "L1", 
                                    date_time = start_date_time,
                                    seed = seed)

        result <- tryCatch(saveRDS(stored, file = file_name),
                           error = function(e) e)
      }
    }
    
    ## Print progress
    if (print_every > 0L & !i %% print_every)
      print(paste("Iteration", i, "completed"))
  }

  ## Here to allow restarts
  stored[["theta"]] <- theta

  ## For bookkeeping
  stored[["run_time"]] <- Sys.time() - start_time

  stored
}
