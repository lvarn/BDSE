% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_Gibbs_sampler_2levela.R
\name{run_Gibbs_sampler_2levela}
\alias{run_Gibbs_sampler_2levela}
\title{Gibbs sampler}
\usage{
run_Gibbs_sampler_2levela(
  seed,
  n_sims,
  obs_distribution,
  formula1,
  formula2,
  proposal_cov_coef1,
  proposal_cov_coef2,
  proposal_sd_cluster_effects1,
  proposal_sd_cluster_effects2,
  prior_mean_coef1,
  prior_mean_coef2,
  prior_cov_coef1,
  prior_cov_coef2,
  clusters_col_name,
  initial_vals = NULL,
  restart_from = NULL,
  cluster_effects_min = -5,
  cluster_effects_max = 5,
  n_clusters = length(unique(obs_distribution[[clusters_col_name]])),
  proposal_scale_coef1 = 1,
  proposal_scale_coef2 = 1,
  func_n_target_posterior = list(func = BDSE:::draw_n_target_jeffreys, args = NULL),
  func_sd_posterior1 = list(func = BDSE:::draw_sd_uniform, args = list(prior_lower =
    0.01, prior_upper = 3)),
  func_sd_posterior2 = list(func = BDSE:::draw_sd_uniform, args = list(prior_lower =
    0.01, prior_upper = 3)),
  periodic_save = NULL,
  print_every = 0L,
  record_count = function(...) FALSE,
  return_obs_dist = FALSE
)
}
\arguments{
\item{seed}{An integer specifying the random seed.}

\item{n_sims}{An integer specifying the number of simulations (or runs of the
Gibbs sampler).}

\item{obs_distribution}{A data.frame of the unique observed unit records.}

\item{formula1, formula2}{Each a formula for creating the design matrix for
the coverage model of the corresponding list (list 1 or 2).}

\item{proposal_cov_coef1, proposal_cov_coef2}{Each a covariance matrix for the
multivariate normal proposal distribution used to draw from the conditional
posterior distribution of the coefficients in the coverage model for the
corresponding list (List 1 or 2).}

\item{proposal_sd_cluster_effects1, proposal_sd_cluster_effects2}{Each a
numeric value specifying the standard deviation of the M-H proposal
distribution for the cluster effects of the corresponding list.}

\item{prior_mean_coef1, prior_mean_coef2}{Each a vector of means for the
normal prior distribution of the coeffcients of the coverage model for the
corresponding list.}

\item{prior_cov_coef1, prior_cov_coef2}{Each a covariance matrix for the
normal prior distribution of the coeffcients of the coverage model for the
corresponding list.}

\item{clusters_col_name}{A string representing the column name of the
clusters variable in the data.frame \code{D_obs}.}

\item{initial_vals}{A named list with initial values for: the coefficients
vectors \code{coefficients1} and \code{coefficients2}; the cluster effects
vectors \code{cluster_effects1} and \code{cluster_effects2}; and the
cluster effects standard deviations (scalars) \code{clusters_sd1} and
\code{clusters_sd2}.}

\item{n_clusters}{An integer specifying the number of unique clusters in the
population. (Defaults to the number of unique clusters in the observed
dataset \code{D_obs}.)}

\item{proposal_scale_coef1, proposal_scale_coef2}{Each a numeric scalar
specifying the scaling factor of the covariance matrix of the M-H proposal
distribution for the coefficients for the corresponding list.}

\item{func_n_target_posterior}{A named list with elements \code{func} and
\code{args} giving the function used to draw from the posterior distrbution
of the target size (\code{n_target}) and the arguments to the function.
(Defaults to the posterior for a Jeffreys prior.)}

\item{func_sd_posterior1, func_sd_posterior2}{Each a named list with elements
\code{func} and \code{args} giving the function used to draw from the
posterior distrbution of the standard deviation parameter of the cluster
effects distribution and the arguments to the function. (Both default to
the posterior for a uniform prior on [0.01, 3].)}

\item{periodic_save}{A named list with two elemnts: \code{every}, an integer
\eqn{n} specifying that every \eqn{n}th iteration must be saved, and
\code{where}, a string specifying the directory where the results should be
saved. (Defaults to \code{NULL}.)}

\item{print_every}{An integer \eqn{n} specifying that after every \eqn{n}th
iteration a progress report should be printed (to console).}

\item{record_count}{A function indicating which counts (iterations) should be
stored in the output object; see \code{\link[BDSE]{record_count}}.}

\item{return_obs_dist}{Logical, indicating whether the observed frequency
distribution should be stored in the output object; defaults to
\code{TRUE}.}
}
\value{
A named list of parameter vectors and scalars generated by the Gibbs
  sampler: 
  \itemize{ 
    \item \code{coefficients1, coefficients2}: Matrices of sampled 
      coefficients for the coverage models of lists 1 and 2; 
    \item \code{update_coef1, update_coef2}: Each a vector indicating whether
      the coefficients vector for the corresponding list was updated at each
      iteration; 
    \item \code{cluster_effects1, cluster_effects2}: Matrices of
      sampled cluster effects for lists 1 and 2; 
    \item \code{update_clus_eff1,
      update_clus_eff2}: Each a matrix indicating which cluster effects for
      the corresponding list were updated at each iteration (row); 
    \item \code{clusters_sd1, clusters_sd2}: Vectors of sampled standard 
      deviations for the cluster effects of Lists 1 and 2; 
    \item \code{n_target} A vector of sampled target population sizes. 
  }
}
\description{
This function runs a Gibbs sampler to approximate the predictive posterior
distribution of the unobserved portion of the target population, given the
observed (in Lists 1 and 2) portion of the population.
}
\details{
The function assumes that, along with the covariates, the data.frame
\code{D_obs} includes columns of indicators, named \code{L1} and \code{L2}
(for the two lists).
}
\examples{
n_obs      <- 100000
n_clusters <- 50
n_sims     <- 10L

L <- data.frame(L1 = c(1, 1, 0),
                L2 = c(1, 0, 1))[sample(3, n_obs, replace = TRUE), ]


D_obs <- data.frame(age     = sample(90, n_obs, replace = TRUE),
                    sex     = sample(c("M", "F"), n_obs, replace = TRUE),
                    Y11     = as.integer(L[[1]] & L[[2]]),
                    Y10     = as.integer(L[[1]] & !L[[2]]),
                    Y01     = as.integer(!L[[1]] & L[[2]]),
                    Y00     = 0L,
                    cluster = c(1:n_clusters,
                                sample(n_clusters, n_obs - n_clusters, 
                                       replace = TRUE)))

obs_distribution <- BDSE::distribute(
                      D_obs,
                      contract_cols = c("Y11", "Y10", "Y01", "Y00"))

cover_formula <- reformulate(c("age", "sex"), response = NULL) 
n_coef1       <- 3  # Intercept, age, and sexM (or sexF)
n_coef2       <- 3

initial_vals  <- list(coefficients1    = c(0.5, 0.001, 0.75),
                      coefficients2    = c(0.5, 0.001, 0.75),
                      clusters_sd1     = 0.8,
                      clusters_sd2     = 0.8,
                      cluster_effects1 = rnorm(n_clusters),
                      cluster_effects2 = rnorm(n_clusters))              

Gibbs_sample <- run_Gibbs_sampler_2levela(
                  seed                         = 296,
                  n_sims                       = n_sims,
                  obs_distribution             = obs_distribution,
                  formula1                     = cover_formula,
                  formula2                     = cover_formula,
                  proposal_cov_coef1           = diag(0.5, nrow = n_coef1),
                  proposal_cov_coef2           = diag(0.5, nrow = n_coef2),
                  proposal_sd_cluster_effects1 = 0.75,
                  proposal_sd_cluster_effects2 = 0.75,
                  prior_mean_coef1             = rep(0, n_coef1),
                  prior_mean_coef2             = rep(0, n_coef2),
                  prior_cov_coef1              = diag(100^2, nrow = n_coef1),
                  prior_cov_coef2              = diag(100^2, nrow = n_coef2),
                  initial_vals                 = initial_vals,
                  clusters_col_name            = "cluster",
                # periodic_save                = list(every = n_sims,
                #                                     where = file.path(getwd(), "out")),
                  print_every                  = 1L)

str(Gibbs_sample)

}
