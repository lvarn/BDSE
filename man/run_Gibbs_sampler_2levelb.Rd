% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_Gibbs_sampler_2levelb.R
\name{run_Gibbs_sampler_2levelb}
\alias{run_Gibbs_sampler_2levelb}
\title{Gibbs sampler (2-level coverage model)}
\usage{
run_Gibbs_sampler_2levelb(
  seed,
  n_sims,
  obs_distribution,
  formula1,
  formula2,
  proposal_cov_coef1,
  proposal_cov_coef2,
  proposal_sd_cluster_effects1,
  proposal_sd_cluster_effects2,
  prior_mean_coef1,
  prior_mean_coef2,
  prior_cov_coef1,
  prior_cov_coef2,
  clusters_col_name,
  initial_vals = NULL,
  restart_from = NULL,
  formula_clus1 = ~1,
  formula_clus2 = ~1,
  prior_mean_coef_clus1,
  prior_mean_coef_clus2,
  prior_cov_coef_clus1,
  prior_cov_coef_clus2,
  D_clus = NULL,
  cluster_effects_min = -Inf,
  cluster_effects_max = Inf,
  n_clusters = length(unique(obs_distribution[[clusters_col_name]])),
  proposal_scale_coef1 = 1,
  proposal_scale_coef2 = 1,
  func_n_target_posterior = list(func = BDSE:::draw_n_target_jeffreys, args = NULL),
  func_sd_posterior1 = list(func = BDSE:::draw_sd_uniform, args = list(prior_lower =
    0.01, prior_upper = 3)),
  func_sd_posterior2 = list(func = BDSE:::draw_sd_uniform, args = list(prior_lower =
    0.01, prior_upper = 3)),
  periodic_save = NULL,
  print_every = 0L,
  record_count = function(...) FALSE,
  return_obs_dist = FALSE
)
}
\arguments{
\item{seed}{An integer specifying the random seed.}

\item{n_sims}{An integer specifying the number of simulations (or runs of the
Gibbs sampler).}

\item{obs_distribution}{A data.frame of the unique observed unit records.}

\item{formula1, formula2}{Each a formula for creating the design matrix for
the coverage model of the corresponding list (list 1 or 2).}

\item{proposal_cov_coef1, proposal_cov_coef2}{Each a covariance matrix for the
multivariate normal proposal distribution used to draw from the conditional
posterior distribution of the coefficients in the coverage model for the
corresponding list (List 1 or 2).}

\item{proposal_sd_cluster_effects1, proposal_sd_cluster_effects2}{Each a
numeric value specifying the standard deviation of the M-H proposal
distribution for the cluster
effects of the corresponding list.}

\item{prior_mean_coef1, prior_mean_coef2}{Each a vector of means for the
normal prior distribution of the coeffcients of the coverage model for the
corresponding list.}

\item{prior_cov_coef1, prior_cov_coef2}{Each a covariance matrix for the
normal prior distribution of the coeffcients of the coverage model for the
corresponding list.}

\item{clusters_col_name}{A string representing the column name of the
clusters variable in the data.frame \code{D_obs}.}

\item{initial_vals}{A named list with initial values for: the coefficients
vectors \code{coefficients1} and \code{coefficients2}; the cluster effects
vectors \code{cluster_effects1} and \code{cluster_effects2}; and the
cluster effects standard deviations (scalars) \code{clusters_sd1} and
\code{clusters_sd2}.}

\item{formula_clus1, formula_clus2}{Each a formula specifying the model for
the mean of the cluster effects in the corresponding list coverage model;
defaults to \code{~ 1}.}

\item{prior_mean_coef_clus1, prior_mean_coef_clus2}{The prior means of
the parameters of the mean of the cluster effects in the corresponding
coverage model.}

\item{prior_cov_coef_clus1, prior_cov_coef_clus2}{The prior variance or
covariance matrix of the parameters of the mean of the cluster effects in
the corresponding coverage model.}

\item{D_clus}{A data.frame of cluster-level covariates; defaults to
\code{NULL}.}

\item{n_clusters}{An integer specifying the number of unique clusters in the
population. (Defaults to the number of unique clusters in the observed
dataset \code{D_obs}.)}

\item{proposal_scale_coef1, proposal_scale_coef2}{Each a numeric scalar
specifying the scaling factor of the covariance matrix of the M-H proposal
distribution for the coefficients for the corresponding list.}

\item{func_n_target_posterior}{A named list with elements \code{func} and
\code{args} giving the function used to draw from the posterior distrbution
of the target size (\code{n_target}) and the arguments to the function.
(Defaults to the posterior for a Jeffreys prior.)}

\item{func_sd_posterior1, func_sd_posterior2}{Each a named list with elements
\code{func} and \code{args} giving the function used to draw from the
posterior distrbution of the standard deviation parameter of the cluster
effects distribution and the arguments to the function. (Both default to
the posterior for a uniform prior on [0.01, 3].)}

\item{periodic_save}{A named list with two elemnts: \code{every}, an integer
\eqn{n} specifying that every \eqn{n}th iteration must be saved, and
\code{where}, a string specifying the directory where the results should be
saved. (Defaults to \code{NULL}.)}

\item{print_every}{An integer \eqn{n} specifying that after every \eqn{n}th
iteration a progress report should be printed (to console).}

\item{record_count}{A function indicating which counts (iterations) should be
stored in the output object; see \code{\link[BDSE]{record_count}}.}

\item{return_obs_dist}{Logical, indicating whether the observed frequency
distribution should be stored in the output object; defaults to
\code{TRUE}.}
}
\value{
A named list of parameter values generated by the Gibbs sampler:
  \itemize{
    \item \code{n_target} A vector of sampled target population sizes;
    \item \code{coefficients1, coefficients2}: Matrices of sampled
      coefficients for the coverage models of lists 1 and 2;
    \item \code{update_coef1, update_coef2}: Each a vector indicating whether
      the coefficients vector for the corresponding list was updated at each
      iteration;
    \item \code{log_like1, log_like2}: Each a vector of log-likelihoods of
      the coverage model coefficients vector for the corresponding list;
    \item \code{cluster_effects1, cluster_effects2}: Matrices of
      sampled cluster effects for lists 1 and 2;
    \item \code{update_clus_eff1, update_clus_eff2}: Each a matrix indicating
      which cluster effects for the corresponding list were updated at each
      iteration (row);
    \item \code{clusters_sd1, clusters_sd2}: Vectors of sampled standard
      deviations for the cluster effects of Lists 1 and 2;
    \item \code{coefficients_clus1, coefficients_clus2}: Matrices of sampled
      cluster-level covariate coefficients for lists 1 and 2.
    \item \code{run_time}: The run-time of the Gibbs sampler.
  }
}
\description{
This function runs a Gibbs sampler to approximate the posterior predictive
distribution of the unobserved portion of the target population, given the
observed (in Lists 1 and 2) portion of the population.
}
\details{
The function assumes that, along with the covariates, the data.frame
\code{obs_distribution} includes columns of counts for the four cells, named
\code{Y11}, \code{Y10}, \code{Y01}, and \code{Y00}.

The cluster effects (random intercepts) in the coverage model are a priori
independent normal variates with a constant variance. In
\code{run_Gibbs_sampler_2levelb}, non-zero means for the prior distribution
of the cluster effects can be spcified by including cluster-level covariates
in the data.frame \code{D_clus}. These cluster effects means are modeled as
linear combinations of the cluster-level covariates, which are specified in
the formulas \code{formula_clus1} and \code{formula_clus2}.

Note that, when \code{D_clus} is \code{NULL}, the cluster effects means are
assumed to be constant for the coverage models of both lists (i.e. model
formula is \code{~ 1}).

The overall/common intercept in the first level of the model is supressed,
and instead included in the second level of the model (as part of the cluster
effects means). A 2-level coverage model with an overall intercept at the
first level of the model is implemented in \code{run_Gibbs_sampler_2levela},
which assumes that cluster effects are a priori independent normal variates
with zero mean and constant variance.
}
\examples{
n_obs      <- 100000
n_clusters <- 50
n_sims     <- 10L

L <- data.frame(L1 = c(1, 1, 0),
                L2 = c(1, 0, 1))[sample(3, n_obs, replace = TRUE), ]

D_obs <- data.frame(age     = sample(90, n_obs, replace = TRUE),
                    sex     = sample(c("M", "F"), n_obs, replace = TRUE),
                    Y11     = as.integer(L[[1]] & L[[2]]),
                    Y10     = as.integer(L[[1]] & !L[[2]]),
                    Y01     = as.integer(!L[[1]] & L[[2]]),
                    Y00     = 0L,
                    cluster = c(1:n_clusters,
                                sample(n_clusters, n_obs - n_clusters, 
                                       replace = TRUE)))

obs_distribution <- BDSE::distribute(
                      D_obs,
                      contract_cols = c("Y11", "Y10", "Y01", "Y00"))

D_clus <- data.frame(cluster      = 1:n_clusters,
                     clus_type    = sample(c("Urban", "Rural"),
                                           n_clusters,
                                           replace = TRUE),
                     clus_density = runif(n_clusters))

## intercept at level 1 will be dropped in the sampler and included at
## level 2 as the mean of the prior distribution of the cluster effects:
formula1 <- formula2 <- ~ age + sex  # coefs: age, and sexM (or sexF)

## cluster coefs: Intercept, clus_typeUrban (or clus_typeRural), clus_density
formula_clus1 <- ~ clus_type + clus_density
formula_clus2 <- ~ 1

initial_vals  <- list(coefficients1     = c(0.001, 0.75),
                      coefficients2     = c(0.002, 0.5),
                      cluster_effects1  = rnorm(n_clusters),
                      cluster_effects2  = rnorm(n_clusters),
                      clusters_sd1      = 0.8,
                      clusters_sd2      = 0.75,
                      coefficients_clus1 = c(0.1, 0.2, 0.1),
                      coefficients_clus2 = 0.2)

n_coef1 <- length(initial_vals[["coefficients1"]])
n_coef2 <- length(initial_vals[["coefficients2"]])

n_clus_coef1 <- length(initial_vals[["coefficients_clus1"]])
n_clus_coef2 <- length(initial_vals[["coefficients_clus2"]])

Gibbs_sample <- run_Gibbs_sampler_2levelb(
                  seed                         = 296,
                  n_sims                       = n_sims,
                  obs_distribution             = obs_distribution,
                  D_clus                       = D_clus,
                  formula1                     = formula1,
                  formula2                     = formula2,
                  formula_clus1                = formula_clus1,
                  formula_clus2                = formula_clus2,
                  proposal_cov_coef1           = diag(0.5, nrow = n_coef1),
                  proposal_cov_coef2           = diag(0.5, nrow = n_coef2),
                  proposal_sd_cluster_effects1 = 0.75,
                  proposal_sd_cluster_effects2 = 0.75,
                  prior_mean_coef1             = rep(0, n_coef1),
                  prior_mean_coef2             = rep(0, n_coef2),
                  prior_cov_coef1              = diag(100^2, nrow = n_coef1),
                  prior_cov_coef2              = diag(100^2, nrow = n_coef2),
                  prior_mean_coef_clus1        = rep(0, n_clus_coef1),
                  prior_mean_coef_clus2        = rep(0, n_clus_coef2),
                  prior_cov_coef_clus1         = diag(10^2, nrow = n_clus_coef1),
                  prior_cov_coef_clus2         = 10^2,
                  initial_vals                 = initial_vals,
                  clusters_col_name            = "cluster",
                # periodic_save                = list(every = n_sims,
                #                                     where = file.path(getwd(), "out")),
                  print_every                  = 1L)

str(Gibbs_sample)

}
