% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/draw_cluster_effects.R
\name{draw_cluster_effects}
\alias{draw_cluster_effects}
\title{Draw from the posterior distribution of group-level effects}
\usage{
draw_cluster_effects(
  current_cluster_effects,
  prior_mean,
  prior_sd,
  proposal_sd,
  X,
  y,
  coefficients,
  clusters,
  n_clusters,
  offsets = 0,
  weights = 1,
  counts = 1,
  min = -Inf,
  max = Inf
)
}
\arguments{
\item{current_cluster_effects}{A numeric vector giving current cluster effect
values.}

\item{prior_mean}{A numeric vector giving the means for the Normal prior
distribution on the cluster effects.}

\item{prior_sd}{The standard deviation for the Normal prior distribution on
the cluster effects.}

\item{proposal_sd}{A numeric value giving the standard deviation for the
(Normal) proposal distribution, with mean vector
\code{current_cluster_effects}.}

\item{X}{A numeric (design) matrix with dimension \eqn{n} x \eqn{p}, where
\code{n} is the number of individuals, and \eqn{p} is the number of
covariates (including the intercept).}

\item{y}{A binary (0, 1) vector of length \eqn{n}, representing observations
of the response variable.}

\item{coefficients}{A numeric vector of length \eqn{p + 1} of
individual-level effects in the logistic regression model, the first
element of which is the intercept.}

\item{clusters}{A vector of length \eqn{n}, with values in
\code{1:n_clusters}, representing the cluster membership of the individual
observations.}

\item{n_clusters}{An integer specifying the number of unique clusters in the
population, some of which may not be represented in the observed data.}

\item{offsets}{A numeric vector giving the known offsets at the unit record
level.}

\item{weights}{An optional numeric vector of length \eqn{n} specifying the
sample weights.}

\item{counts}{A numeric vector of counts of the number of observations in
each corresponding row of the design matrix \code{X}.}
}
\value{
A named list, with the following elements:
\itemize{
    \item \code{cluster_effects}: the vector of sampled cluster_effects;
    \item \code{was_updated}: a logical vector, the same length as
      \code{cluster_effects}, indicating whether the cluster effects
      were updated in the Metropolis-Hastings run.
}
}
\description{
This function uses the Metropolis-Hastings algorithm with the symmetric
proposal distribution
\preformatted{
 Normal(current_cluster_effects, proposal_sd),
}
to draw from the posterior distribution of the group-level or cluster-level
effects. These parameters form the offsets (or random intercept) of a
logistic regression model. The prior distribution of these cluster effects,
with known mean and standard deviation, is given by
\preformatted{
 Normal(prior_mean, prior_sd).
}
}
\details{
This function is a single iteration of the Metropolis-Hastings algorithm,
and is intended for use within a Gibbs sampler.
}
\examples{
n               <- 1000    # number of observations
n_clusters      <- 50      # number of clusters
clusters        <- sample(n_clusters, n, replace = TRUE)
X               <- cbind('(Intercept)' = rep(1, n),
                         age           = runif(n, 1, 85),
                         sexM          = rbinom(n, 1, 0.45))
y               <- rbinom(n, 1, 0.7)
coefficients    <- c(0.5, 0.01, -1)         # individual-level effects
cluster_effects <- runif(n_clusters, -1, 1) # group-level effects
prior_mean      <- rnorm(n_clusters, 0, 1)
prior_sd        <- 2
proposal_sd     <- 1.25
offsets         <- rnorm(n, 0, 1)  # unit-record-level offsets

res <- draw_cluster_effects(current_cluster_effects = cluster_effects,
                            prior_mean              = prior_mean,
                            prior_sd                = prior_sd,
                            proposal_sd             = proposal_sd,
                            X                       = X,
                            y                       = y,
                            coefficients            = coefficients,
                            clusters                = clusters,
                            n_clusters              = n_clusters,
                            offsets                 = offsets)

head(res[["cluster_effects"]])
table(res[["was_updated"]])

}
